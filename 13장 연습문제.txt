13장 연습문제

1. 왜 데이터 API를 사용해야 하나요?
 : 대용량 데이터셋을 읽고 효율적으로 전처리하는 것은 복잡한 엔지니어링 업무입니다.
데이터 API를 사용하면 매우 간단합니다. 데이터 API는 많은 기능을 제공합니다. (텍스트나
이진 파일과 같은) 다양한 소스에서 데이터를 적재하거나 동시에 여러 소스에서 데이터를
읽고, 변환하고, 레코드를 교대로 처리하고, 데이터를 섞을 수 있스비다. 배치와 프리페치
기능도 제공합니다.

2. 대용량 데이터셋을 여러 파일로 나누면 어떤 장점이 있나요?
 : 대용량 데이터셋을 여러 파일로 나누면 셔플링 버퍼를 사용해 데이터를 잘게 섞기 전에
크게 섞을 수 있습니다. 또한 한 대의 컴퓨터에 담을 수 없는 아주 큰 데이터셋을 다룰 수
있습니다. 하나의 큰 파일보다 수천 개의 작은 파일을 다루는 것이 쉽습니다. 예를 들어
데이터를 여러 개의 서브 세트로 나누기 쉽습니다. 마지막으로 여러 대의 서버에 여러 파일로
데이터를 나누면 동시에 여러 서버에서 파일을 다운로드할 수 있어 네트워크 밴드위스를
효율적으로 사용할 수 있습니다.

3. 훈련 과정에서 입력 파이프라인의 병목을 어떻게 찾을 수 있나요? 어떻게 병목현상을
고칠 수 있나요?
 : 텐서보드를 사용해 프로파일링 데이터를 시각화할 수 있습니다. GPU가 완전히 활용되지
않고 입력 파이프라인에 병목현상이 보인다면 여러 스레드에서 동시에 데이터를 읽고
전처리하여 몇 개의 배치를 프리페치하여 해결할 수 있습니다. 이렇게 해도 훈련할 때
GPU를 100% 사용하지 못한다면 전처리 코드를 최적화해볼 수 있습니다. 훈련하는 동안
동시에 전처리할 필요가 없다면 데이터셋을 여러 개의 TFRecord 파일로 저장하고 미리
전처리를 수행할 수 있습니다(TF 변환을 사용하면 도움이 됩니다). 필요하다면 더 많은
GPU와 RAM을 가진 머신을 사용하고 GPU 밴드위스가 충분한지 확인하세요.

4. 어떤 이진 데이터도 TFRecord 파일 또는 직렬화된 프로토콜 버퍼로 저장할 수 있나요?
 : 하나의 TFRecord 파일은 임의의 이진 레코드의 시퀀스로 구성됩니다. 각 레코드에
원하는 어떤 이진 데이터도 저장할 수 있습니다. 하지만 대부분의 TFRecord 파일은 직렬화된
프로토콜 버퍼의 시퀀스를 가집니다. 이렇게 하면 여러 가지 프로토콜 버퍼의 장점을 사용할
수 있습니다. 다양한 플랫폼과 언어에서 쉽게 읽을 수 있고 호환성을 유지하면서 프로토콜
정의를 업데이트할 수 있습니다.

5. 모든 데이터를 Example 프로토콜 버퍼 포맷으로 변환해야 하나요? 자신만의
프로토콜 버퍼 정의를 사용하는 것은 어떤가요?
 : 

6. TFRecord를 사용할 때 언제 압축을 사용하나요? 왜 기본적으로 압축을 사용하지 않나요?
 : 

7. 데이터 파일을 작성할 때, 또는 tf.data 파이프라인 안에서, 모델의 전처리 층에서, TF
변환을 사용하여 데이터를 전처리할 수 있습니다. 각 방식의 장단점을 설명할 수 있나요?
 : 

8. 범주형 특성을 인코딩할 수 있는 대표적인 방법을 나열해보세요. 텍스트 데이터는 어떻게
인코딩할 수 있나요?
 : 영화에 대한 평가(예를 들어 '나쁨', '보통', '좋음')와 같이 자연스러운 순서가 있는 범주형
특성을 인코딩하기 위한 가장 간단한 방법은 순서가 있는 인코딩을 사용하는 것입니다. 범주를
순서대로 나열하고 범주를 각각의 순위에 매핑합니다(예를 들어 '나쁨'은 0, '보통'은 1, '좋음'은
2에 매핑합니다). 하지만 대부분의 범주형 특성은 내재된 순서가 없습니다. 예를 들어 직업이나
나라에는 순서가 없습니다. 이런 경우에는 원-핫 인코딩을 사용할 수 있고 범주가 많다면
임베딩을 사용합니다.
텍스트를 위한 한 가지 방법은 BoW 표현을 사용하는 것입니다. 문장을 가능한 단어의 카운트
벡터로 표현합니다. 자주 등장하는 단어는 중요하지 않기 때문에 TF-IDF를 사용해 가중치를
낮춥니다. 단어를 카운트하는 대신 종종 n개의 단어가 연속된 n-그램을 카운트합니다. 간단하고
좋은 방법입니다. 또 다른 방식으로 사전 훈련된 단어 임베딩을 사용해 각 단어를 인코딩할 수
있습니다. 단어를 인코딩하는 대신 각 글자를 인코딩하거나 부분 토큰을 인코딩할 수도 있습니다.
(예를 들어 smartest를 'smart'와 'est'로 나눕니다.)